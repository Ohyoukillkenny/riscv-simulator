000000000100 00000 000 00010 0010011  # ADDI imm=4, rs1=x0  rd=x2 -> x2 = 4
000000000001 00000 000 00101 0010011  # ADDI imm=1, rs1=x0  rd=x5 -> x5 = 1
0000000 00010 00101 010 10010 0100011 # SW  offset1=0, src=x2, base=x5, offset2=18 -> save *x2 to addr: (*x5+18)
                                      #                                            -> save *x2 to addr: sram(19)
000000010011 00000 010 00101 0000011  # lw imm=19, rs1=x0  rd=x5 -> mem_addr = 0 + 4, load sram(19) to x5
0000000 01010 10011 000 10010 0110011 # add x18,x19,x10



/*

ADDI imm=388, rs1=x0  rd=x2 -> x2 = 0b000110000100 = 256+128+4 = 388
ADDI imm=1, rs1=x0  rd=x5 -> x5 = 1
SW  offset1=0, src=x2, base=x5, offset2=18 -> save 388 to mem(1+18)
lb imm=19, rs1=x0  rd=x5 -> mem_addr = 0 + 19, load sram(19)'s byte to x5
      without sign-extension, x5 = 0x00000084 = 128+4 = 132
=> x2 = 388, x5 = 132, sram[19] = 388
*/
00011000010000000000000100010011
00000000000100000000001010010011
00000000001000101010100100100011
00000001001100000100001010000011


branching instructions
000000000001 00000 000 00101 0010011  # ADDI imm=1, rs1=x0  rd=x5 -> x5 = 1
000000000001 00101 000 00101 0010011  # ADDI imm=1, rs1=x5  rd=x5 -> x5 = x5 + 1 -> x5=2

0 000000 00000 00101 000 0100 0 1100011 # BEQ offset=8, rs2=x0, rs1=x5
000000000001 00101 000 00101 0010011  # ADDI imm=1, rs1=x5  rd=x5 -> x5 = x5 + 1 -> x5=3

write a loop for branching
000000000100 00000 000 00110 0010011  # ADDI imm=8, rs1=x0  rd=x6 -> x6 = 8
000000000001 00000 000 00101 0010011  # ADDI imm=1, rs1=x0  rd=x5 -> x5 = 1
000000000001 00101 000 00101 0010011  # ADDI imm=1, rs1=x5  rd=x5 -> x5 = x5 + 1
1 111111 00101 00110 101 1110 1 1100011 # BGE offset=-4, rs2=x5, rs1=x6
000000000001 00101 000 00101 0010011  # ADDI imm=1, rs1=x5  rd=x5 -> x5 = x5 + 1


1: x6 = 8
2: x5 = 1
3: x5 = x5 + 1
4: if (x6 >= x5), branch back to instr 3
5: x5 = x5 + 1 -> x5 = 9








